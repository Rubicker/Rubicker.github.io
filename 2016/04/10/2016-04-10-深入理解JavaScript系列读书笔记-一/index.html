<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="">
    <meta name="keyword"  content="">
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
          深入理解JavaScript系列读书笔记 - Rubicker的博客 | Rubicker&#39;s Blog
        
    </title>

    <link rel="canonical" href="http://rubicker.github.io/2016/04/10/2016-04-10-深入理解JavaScript系列读书笔记-一/">

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="/css/bootstrap.min.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/hux-blog.min.css">

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="/css/highlight.css">

    <!-- Custom Fonts -->
    <!-- <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
    <!-- Hux change font-awesome CDN to qiniu -->
    <link href="http://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">


    <!-- Hux Delete, sad but pending in China
    <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/
    css'>
    -->


    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- ga & ba script hoook -->
    <script></script>
</head>


<!-- hack iOS CSS :active style -->
<body ontouchstart="">

    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Rubicker&#39;s Blog</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <!-- Known Issue, found by Hux:
            <nav>'s height woule be hold on by its content.
            so, when navbar scale out, the <nav> will cover tags.
            also mask any touch event of tags, unfortunately.
        -->
        <div id="huxblog_navbar">
            <div class="navbar-collapse">
                <ul class="nav navbar-nav navbar-right">
                    <li>
                        <a href="/">Home</a>
                    </li>

                    

                        
                    

                        
                        <li>
                            <a href="/archives/">Archives</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/about/">About</a>
                        </li>
                        
                    

                        
                        <li>
                            <a href="/tags/">Tags</a>
                        </li>
                        
                    
                    
                </ul>
            </div>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>
<script>
    // Drop Bootstarp low-performance Navbar
    // Use customize navbar with high-quality material design animation
    // in high-perf jank-free CSS3 implementation
    var $body   = document.body;
    var $toggle = document.querySelector('.navbar-toggle');
    var $navbar = document.querySelector('#huxblog_navbar');
    var $collapse = document.querySelector('.navbar-collapse');

    $toggle.addEventListener('click', handleMagic)
    function handleMagic(e){
        if ($navbar.className.indexOf('in') > 0) {
        // CLOSE
            $navbar.className = " ";
            // wait until animation end.
            setTimeout(function(){
                // prevent frequently toggle
                if($navbar.className.indexOf('in') < 0) {
                    $collapse.style.height = "0px"
                }
            },400)
        }else{
        // OPEN
            $collapse.style.height = "auto"
            $navbar.className += " in";
        }
    }
</script>


    <!-- Main Content -->
    
<!-- Image to hack wechat -->
<!-- <img src="http://rubicker.github.io/img/icon_wechat.png" width="0" height="0"> -->
<!-- <img src="{{ site.baseurl }}/{% if page.header-img %}{{ page.header-img }}{% else %}{{ site.header-img }}{% endif %}" width="0" height="0"> -->

<!-- Post Header -->
<style type="text/css">
    header.intro-header{
        background-image: url('/img/home-bg.jpg')
    }
</style>
<header class="intro-header" >
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <div class="tags">
                        
                          <a class="tag" href="/tags/#JavaScript" title="JavaScript">JavaScript</a>
                        
                    </div>
                    <h1>深入理解JavaScript系列读书笔记</h1>
                    <h2 class="subheading"></h2>
                    <span class="meta">
                        Posted by Rubicker on
                        2016-04-10
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

    <!-- Post Container -->
            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                post-container">

                <blockquote>
<p>总结自汤姆大叔分享的文章——<a href="http://www.cnblogs.com/TomXu/archive/2011/12/15/2288411.html#3371194" target="_blank" rel="external">深入理解JavaScript系列</a></p>
</blockquote>
<a id="more"></a>
<h3 id="编写高质量JavaScript代码的基本要点"><a href="#编写高质量JavaScript代码的基本要点" class="headerlink" title="编写高质量JavaScript代码的基本要点"></a>编写高质量JavaScript代码的基本要点</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><hr>
<ul>
<li><p>尽量避免使用全局变量</p>
<p> 由于JavaScript应用程序和Web页面上的所有代码都共享了全局变量，所以存在命名冲突</p>
<p> 有可能创建全局变量的情况：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</div><div class="line"><span class="comment">// 不推荐写法: 隐式全局变量  </span></div><div class="line"><span class="comment">// result没有声明，但是代码正常</span></div><div class="line"><span class="comment">// 因此result成为了一个全局变量</span></div><div class="line">result = x + y;</div><div class="line"><span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> a = b = <span class="number">1</span>;    </div><div class="line"><span class="comment">// a是局部变量，而b是全局变量  </span></div><div class="line"><span class="comment">// 赋值是从右向左的！</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 关于上述第二个例子，还有一个较为有趣的面试题与之相似：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> foo = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">var</span> bar = foo;</div><div class="line">foo.x = foo = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</div><div class="line"><span class="built_in">console</span>.log(foo.x)   <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p> <a href="http://www.cnblogs.com/xxcanghai/p/4998076.html" target="_blank" rel="external">解答戳此</a></p>
</li>
<li><p>漏写var的副作用</p>
<ul>
<li>通过var创建的全局变量（除函数外）是不能被删除的；</li>
<li>无var创建的隐式全局变量（不论是否在函数）是可以被删除的（此时被视作全局对象的属性，而属性是可以通过delete操作符删除的） <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> global_var = <span class="number">1</span>;</div><div class="line">global_novar = <span class="number">2</span>;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> a = <span class="number">3</span> ;</div><div class="line">&#125;)();</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    b = <span class="number">4</span> ;</div><div class="line">&#125;)();</div><div class="line"><span class="comment">//删除</span></div><div class="line"><span class="keyword">delete</span> global_var;</div><div class="line"><span class="keyword">delete</span> global_novar;</div><div class="line"><span class="comment">/*delete a;*/</span></div><div class="line"><span class="keyword">delete</span> b;</div><div class="line"><span class="comment">//测试是否删除</span></div><div class="line"><span class="keyword">typeof</span> global_var;<span class="comment">//   number </span></div><div class="line"><span class="keyword">typeof</span> global_novar;<span class="comment">//  undefined</span></div><div class="line"><span class="keyword">typeof</span> a;<span class="comment">//  undefined</span></div><div class="line"><span class="keyword">typeof</span> b;<span class="comment">//  undefined</span></div></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>单var形式</p>
<p> 在函数顶部使用单var语句：</p>
<p>  1.提供了一个单一的地方去寻找功能所需要的所有局部变量<br>  2.防止变量在定义之前使用的逻辑错误（也就是说未定义和定义未声明在JS中类型均为undefined）<br>  3.减少代码量</p>
</li>
<li><p>var散布的问题——变量提升(Hoisting)</p>
<p> JS中，我们可以在函数任意位置声明多个var语句，而他们表现的像都在顶部声明一样，此即为变量提升。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">global_a = <span class="number">1</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert(a);<span class="comment">// undedined</span></div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  alert(a);<span class="comment">// 2</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 为何第一个输出的不是我们所预想的1呢？<br> 因为变量提升，使得a成为该函数中的局部变量且在<code>alert(a)；</code>之前未定义。</p>
</li>
</ul>
<h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><hr>
<p>   循环某个数组或者类似对象时候，你可能会采取下列做法：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不推荐，多次获取长度，降低代码效率</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; someArray.length ; i++)&#123;</div><div class="line"><span class="comment">//dosomething </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   更好的做法是将长度缓存下来：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//推荐</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>,max = someArray.length; i &lt; max ; i++)&#123;</div><div class="line"><span class="comment">//dosomething </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   改进1：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//减少了一个变量max</span></div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = someArray.length ; i--)&#123;</div><div class="line"><span class="comment">//dosomething </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   改进2:<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//向下数到0，比前述效率要高很多</span></div><div class="line"><span class="keyword">var</span> i = someArray.length;</div><div class="line"><span class="keyword">while</span>(i--)&#123;</div><div class="line"><span class="comment">//dosomething </span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="for-in循环"><a href="#for-in循环" class="headerlink" title="for-in循环"></a>for-in循环</h4><hr>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 对象</span></div><div class="line"><span class="keyword">var</span> man = &#123;</div><div class="line"><span class="attr">hands</span>: <span class="number">2</span>,</div><div class="line"><span class="attr">legs</span>: <span class="number">2</span>,</div><div class="line"><span class="attr">heads</span>: <span class="number">1</span></div><div class="line"> &#125;;</div><div class="line"><span class="comment">// 在代码的某个地方</span></div><div class="line"><span class="comment">// 一个方法添加给了所有对象</span></div><div class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Object</span>.prototype.clone === <span class="string">"undefined"</span>) &#123;</div><div class="line"><span class="built_in">Object</span>.prototype.clone = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</code></pre><p>   此时由于Object是man的原型，所以man将可以访问这个方法。因此为了避免枚举man中的属性的时候出现clone()方法，我们需要应用<code>hasOwnProperty()</code>过滤原型属性。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// for-in 循环</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> man) &#123;</div><div class="line"><span class="keyword">if</span> (man.hasOwnProperty(i)) &#123; <span class="comment">// 过滤</span></div><div class="line">  <span class="built_in">console</span>.log(i, <span class="string">":"</span>, man[i]);</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 控制台显示结果</span></div><div class="line">hands : 2</div><div class="line">legs : 2</div><div class="line">heads : 1</div><div class="line"> */</div></pre></td></tr></table></figure></p>
<p>   有可能在man对象中重写了hasOwnProperty方法，此时：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> man) &#123;</div><div class="line"><span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(man, i)) &#123; <span class="comment">// 过滤</span></div><div class="line">  <span class="built_in">console</span>.log(i, <span class="string">":"</span>, man[i]);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   当然这个方法最好缓存下来：<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> i, hasOwn = <span class="built_in">Object</span>.prototype.hasOwnProperty;</div><div class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> man) &#123;</div><div class="line"><span class="keyword">if</span> (hasOwn.call(man, i)) &#123; <span class="comment">// 过滤</span></div><div class="line">    <span class="built_in">console</span>.log(i, <span class="string">":"</span>, man[i]);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="switch模式"><a href="#switch模式" class="headerlink" title="switch模式"></a>switch模式</h4><hr>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> inspect_me = <span class="number">0</span>,</div><div class="line">result = <span class="string">''</span>;</div><div class="line"><span class="keyword">switch</span> (inspect_me) &#123;</div><div class="line"><span class="keyword">case</span> <span class="number">0</span>:</div><div class="line">    result = <span class="string">"zero"</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">case</span> <span class="number">1</span>:</div><div class="line">    result = <span class="string">"one"</span>;</div><div class="line">    <span class="keyword">break</span>;</div><div class="line"><span class="keyword">default</span>:</div><div class="line">   result = <span class="string">"unknown"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 这个简单的例子中所遵循的风格约定如下：</p>
<ul>
<li>每个case和switch对齐（花括号缩进规则除外）</li>
<li>每个case中代码缩进</li>
<li>每个case以break清除结束</li>
<li>避免忽略break</li>
<li>以default结束switch：确保总有健全的结果，即使无情况匹配。</li>
</ul>
<h4 id="避免隐式类型转换"><a href="#避免隐式类型转换" class="headerlink" title="避免隐式类型转换"></a>避免隐式类型转换</h4><hr>
<p>避免使用 == 操作符，始终使用 === 和 !== 操作符</p>
<h4 id="避免使用eval"><a href="#避免使用eval" class="headerlink" title="避免使用eval()"></a>避免使用eval()</h4><hr>
<p>eval()接收任意字符串，并当作JS代码处理。很有可能代码被恶意修改</p>
<p>当处理Ajax请求得到的JSON响应的时候，最好使用JSON.parse()方法，若浏览器不支持，使用来自JSON,org的库（how?）</p>
<p>如果必须使用eval()，最好用函数将其封装起来，这样在其中通过var定义的变量不会变成全局变量</p>
<h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><hr>
<ul>
<li>使用大写字母写构造函数，帮助理解这个是构造函数，还是一个正常的函数</li>
<li>全局变量名字全部大写</li>
<li>私有成员名字添加下划线前缀</li>
</ul>
<h3 id="揭秘命名函数表达式"><a href="#揭秘命名函数表达式" class="headerlink" title="揭秘命名函数表达式"></a>揭秘命名函数表达式</h3><h4 id="函数表达式和函数声明"><a href="#函数表达式和函数声明" class="headerlink" title="函数表达式和函数声明"></a>函数表达式和函数声明</h4><hr>
<blockquote>
<p>ECMA规范规定：函数声明必须有标识符，函数表达式则可以省略</p>
<p>根据上下文来判断一个有标识符的函数是函数声明还是函数表达式</p>
</blockquote>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 声明，因为它是程序的一部分</span></div><div class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 表达式，因为它是赋值表达式的一部分</span></div><div class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 表达式，因为它是new表达式</span></div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 声明，因为它是函数体的一部分</span></div><div class="line">&#125;)();</div><div class="line"> (<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;); <span class="comment">// 函数表达式</span></div><div class="line"><span class="comment">//包含在分组操作符（）内,分组操作符只能包括表达式，不能是语句</span></div></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>函数声明提升</p>
<p> 函数声明会在任何表达式被解析和求值之前解析</p>
</li>
</ul>
<h4 id="命名函数表达式"><a href="#命名函数表达式" class="headerlink" title="命名函数表达式"></a>命名函数表达式</h4><pre><code><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">    var f = function foo()&#123;</div><div class="line">    return typeof foo; // foo是在内部作用域内有效</div><div class="line">    &#125;;</div><div class="line">    // foo在外部是不可见的</div><div class="line">    typeof foo; // "undefined"</div><div class="line">    f(); // "function"</div><div class="line"></div><div class="line">#### 调试器中的函数名</div><div class="line"> 如果一个函数有名字，那调试器在调试的时候会将它的名字显示在调用的栈上。有些调试器（Firebug）有时候还会为你们函数取名并显示，让他们和那些应用该函数的便利具有相同的角色</div><div class="line"></div><div class="line">#### 浏览器中的BUG</div><div class="line"></div><div class="line">- 函数表达式的标识符泄漏到外部作用域</div><div class="line">    ```javascript</div><div class="line">    var f = function g()&#123;&#125;;</div><div class="line">    console.log(typeof g);</div><div class="line">    // IE9以下"function"</div><div class="line">    // IE9及以上已经修复了这个BUG</div></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>将命名函数表达式同时当作函数声明和函数表达式</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> g; <span class="comment">// "function"  同样是IE问题，9以上undefined</span></div><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;&#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>命名函数表达式会创建两个截然不同的函数对象</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f === g); <span class="comment">// false 又是IE问题</span></div><div class="line">f.expando = <span class="string">'foo'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> g.expando); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
</li>
<li><p>仅仅顺序解析函数声明而忽略条件语句块</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</div><div class="line">  f = <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">g(); <span class="comment">// 2</span></div><div class="line">f();  <span class="comment">// 1</span></div></pre></td></tr></table></figure>
</li>
<li><p>在不包含声明的赋值语句中使用命名函数表达式</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">f = <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
</li>
</ul>
<p>首先他把表达式当成函数声明解析了，所以左边的f被声明为局部变量了（和一般的匿名函数里的声明一样），然后在函数执行的时候，f已经是定义过的了，右边的function f(){}则直接就赋值给局部变量f了，所以f根本就不是全局属性。</p>
<blockquote>
<p>如何预防这些BUG？</p>
<p>首先防范标识符泄漏带外部作用域;其次,永远不引用被用作函数名称的标识符；最后，一定要把命名函数表达式声明期间错误创建的函数清理干净</p>
</blockquote>
<h4 id="JS的内存管理"><a href="#JS的内存管理" class="headerlink" title="JS的内存管理"></a>JS的内存管理</h4><p>暂放，不是很懂～</p>
<h3 id="全面解析Module模式"><a href="#全面解析Module模式" class="headerlink" title="全面解析Module模式"></a>全面解析Module模式</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><hr>
<ul>
<li><p>匿名闭包</p>
<p> 闭包保证了内部代码处于私有状态</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// ... 所有的变量和function都在这里声明，并且作用域也只能在这个匿名闭包里</span></div><div class="line"><span class="comment">// ...但是这里的代码依然可以访问外部全局的对象</span></div><div class="line">&#125;());</div></pre></td></tr></table></figure>
<p> 注意，匿名函数后面的括号，这是JavaScript语言所要求的，因为如果不使用括号的话，JavaScript解释器默认是声明一个function函数，有括号，就是创建一个函数表达式，也就是自执行，用的时候不用new了。</p>
</li>
<li><p>引用全局变量</p>
<p> 我们可以将全局变量当成一个参数传入到匿名函数然后使用，相比隐式全局变量，它又清晰又快</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">$, YAHOO</span>) </span>&#123;</div><div class="line"><span class="comment">// 这里，我们的代码就可以使用全局的jQuery对象了，YAHOO也是一样</span></div><div class="line">&#125; (jQuery, YAHOO));</div></pre></td></tr></table></figure>
<p> 如果想声明全局变量，如何做呢？我们可以通过匿名函数的返回值来返回这个全局变量</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> my = &#123;&#125;, privateName = <span class="string">"博客园"</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateAddTopic</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="comment">// 这里是内部处理代码</span></div><div class="line">  &#125;</div><div class="line">  my.Name = privateName;</div><div class="line">  my.AddTopic = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">      privateAddTopic(data);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> my;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<p> 上面的代码声明了一个全局变量blogModule，并且带有2个可访问的属性：blogModule.AddTopic和blogModule.Name，除此之外，其它代码都在匿名函数的闭包里保持着私有状态。</p>
</li>
</ul>
<h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><hr>
<ul>
<li><p>扩展</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</div><div class="line">my.AddPhoto = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">//添加内部代码  </span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> my;</div><div class="line">&#125; (blogModule));</div></pre></td></tr></table></figure>
<p> 这样就可以将一个功能分离成多个块，多人合作，将每个人实现的功能添加给blogModule（var可以省略？）</p>
</li>
<li><p>松耦合扩展</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123; </div><div class="line"><span class="comment">// 添加一些功能    </span></div><div class="line"><span class="keyword">return</span> my;</div><div class="line">&#125; (blogModule || &#123;&#125;));</div></pre></td></tr></table></figure>
<p> 通过这样的代码，每个单独分离的文件都保证这个结构就可以实现任意顺序的加载（var不可以省略？） </p>
</li>
<li><p>紧耦合扩展</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> oldAddPhotoMethod = my.AddPhoto;</div><div class="line">my.AddPhoto = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 重载方法，依然可通过oldAddPhotoMethod调用旧的方法</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> my;</div><div class="line">&#125; (blogModule));</div></pre></td></tr></table></figure>
<p> 实现重载，但是限制了加载顺序</p>
</li>
<li><p>克隆与继承</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params">old</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> my = &#123;&#125;,</div><div class="line">    key;</div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> old) &#123;</div><div class="line">    <span class="keyword">if</span> (old.hasOwnProperty(key)) &#123;</div><div class="line">        my[key] = old[key];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> oldAddPhotoMethod = old.AddPhoto;</div><div class="line">my.AddPhoto = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// 克隆以后，进行了重写，当然也可以继续调用oldAddPhotoMethod</span></div><div class="line">&#125;;</div><div class="line"><span class="keyword">return</span> my;</div><div class="line">&#125; (blogModule));</div></pre></td></tr></table></figure>
</li>
<li><p>跨文件共享私有对象</p>
<p> 如果一个module分割到多个文件的话，每个文件需要保证一样的结构，也就是说每个文件匿名函数里的私有对象都不能交叉访问，那如果我们非要使用，那怎么办呢？</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> blogModule = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> _private = my._private = my._private || &#123;&#125;,  </div><div class="line">    _seal = my._seal = my._seal || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">delete</span> my._private;</div><div class="line">        <span class="keyword">delete</span> my._seal;</div><div class="line">        <span class="keyword">delete</span> my._unseal;      </div><div class="line">    &#125;,   </div><div class="line">    _unseal = my._unseal = my._unseal || <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        my._private = _private;</div><div class="line">        my._seal = _seal;</div><div class="line">        my._unseal = _unseal;</div><div class="line">    &#125;;       </div><div class="line"><span class="keyword">return</span> my;</div><div class="line">&#125; (blogModule || &#123;&#125;));</div></pre></td></tr></table></figure>
<p> 任何文件都可以对他们的局部变量_private设属性，并且设置对其他的文件也立即生效。一旦这个模块加载结束，应用会调用 blogModule._seal()”上锁”，这会阻止外部接入内部的_private。如果这个模块需要再次增生，应用的生命周期内，任何文件都可以调用_unseal() ”开锁”，然后再加载新文件。加载后再次调用 _seal()”上锁”。</p>
</li>
<li><p>子模块</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">blogModule.CommentSubModule = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> my = &#123;&#125;;</div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">return</span> my;</div><div class="line">&#125; ());</div></pre></td></tr></table></figure>
<p> 子模块也具有一般模块所有的高级使用方式</p>
</li>
</ul>
<h3 id="立即调用的函数表达式"><a href="#立即调用的函数表达式" class="headerlink" title="立即调用的函数表达式"></a>立即调用的函数表达式</h3><h4 id="什么是自执行"><a href="#什么是自执行" class="headerlink" title="什么是自执行"></a>什么是自执行</h4><hr>
<p>在JavaScript里，任何function在执行的时候都会创建一个执行上下文，因为为function声明的变量和function有可能只在该function内部，这个上下文，在调用function的时候，提供了一种简单的方式来创建自由变量或私有子function。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 由于该function里返回了另外一个function，其中这个function可以访问自由变量i</span></div><div class="line"><span class="comment">// 所有说，这个内部的function实际上是有权限可以调用内部的对象。</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeCounter</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// 只能在makeCounter内部访问i</span></div><div class="line"><span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(++i);</div><div class="line">&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面这个function在语法上是没问题的，但是依然只是一个语句</span></div><div class="line"><span class="comment">// 加上括号()以后依然会报错，因为分组操作符需要包含表达式</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;(); <span class="comment">// SyntaxError: Unexpected token )</span></div><div class="line"><span class="comment">// 但是如果你在括弧()里传入一个表达式，将不会有异常抛出</span></div><div class="line"><span class="comment">// 但是foo函数依然不会执行</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125;( <span class="number">1</span> );</div><div class="line"><span class="comment">// 因为它完全等价于下面这个代码，一个function声明后面，又声明了一个毫无关系的表达式： </span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* code */</span> &#125; </div><div class="line">( <span class="number">1</span> );</div></pre></td></tr></table></figure>
</code></pre><p>   在一个表达式后面加上括号()，该表达式会立即执行，但是在一个语句后面加上括号()，是完全不一样的意思，他的只是分组操作符。</p>
<h4 id="自执行函数表达式"><a href="#自执行函数表达式" class="headerlink" title="自执行函数表达式"></a>自执行函数表达式</h4><hr>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 下面2个括弧()都会立即执行</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ()); <span class="comment">// 推荐使用这个</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;)(); <span class="comment">// 但是这个也是可以用的</span></div><div class="line"><span class="comment">// 由于括弧()和JS的&amp;&amp;，异或，逗号等操作符是在函数表达式和函数声明上消除歧义的</span></div><div class="line"><span class="comment">// 所以一旦解析器知道其中一个已经是表达式了，其它的也都默认为表达式了</span></div><div class="line"><span class="comment">// 不过，请注意下一章节的内容解释</span></div><div class="line"><span class="keyword">var</span> i = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125; ();</div><div class="line"><span class="literal">true</span> &amp;&amp; <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ();</div><div class="line"><span class="number">0</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ();</div><div class="line"><span class="comment">// 如果你不在意返回值，或者不怕难以阅读</span></div><div class="line"><span class="comment">// 你甚至可以在function前面加一元操作符号</span></div><div class="line">!<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ();</div><div class="line">~<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ();</div><div class="line"> -<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ();</div><div class="line"> +<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ();</div><div class="line"><span class="comment">// 还有一个情况，使用new关键字,也可以用，但不确定它的效率</span></div><div class="line"><span class="comment">// http://twitter.com/kuvos/status/18209252090847232</span></div><div class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125;</div><div class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; () <span class="comment">// 如果需要传递参数，只需要加上括弧()</span></div></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>用闭包保存状态</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这个代码是错误的，因为变量i从来就没背locked住</span></div><div class="line"><span class="comment">// 相反，当循环执行以后，我们在点击的时候i才获得数值</span></div><div class="line"><span class="comment">// 因为这个时候i才真正获得值</span></div><div class="line"><span class="comment">// 所以说无论点击那个连接，最终显示的都是I am link #10（如果有10个a元素的话）</span></div><div class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elems.length; i++) &#123;</div><div class="line">elems[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">    e.preventDefault();</div><div class="line">    alert(<span class="string">'I am link #'</span> + i);</div><div class="line">&#125;, <span class="string">'false'</span>);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 这个是可以用的，因为他在自执行函数表达式闭包内部</span></div><div class="line"><span class="comment">// i的值作为locked的索引存在，在循环执行结束以后，尽管最后i的值变成了a元素总数（例如10）</span></div><div class="line"><span class="comment">// 但闭包内部的lockedInIndex值是没有改变，因为他已经执行完毕了</span></div><div class="line"><span class="comment">// 所以当点击连接的时候，结果是正确的</span></div><div class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elems.length; i++) &#123;</div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">lockedInIndex</span>) </span>&#123;</div><div class="line">    elems[i].addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">        e.preventDefault();</div><div class="line">        alert(<span class="string">'I am link #'</span> + lockedInIndex);</div><div class="line">    &#125;, <span class="string">'false'</span>);</div><div class="line">&#125;)(i);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 你也可以像下面这样应用，在处理函数那里使用自执行函数表达式</span></div><div class="line"><span class="comment">// 而不是在addEventListener外部</span></div><div class="line"><span class="comment">// 但是相对来说，上面的代码更具可读性</span></div><div class="line"><span class="keyword">var</span> elems = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'a'</span>);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; elems.length; i++) &#123;</div><div class="line">elems[i].addEventListener(<span class="string">'click'</span>, (<span class="function"><span class="keyword">function</span> (<span class="params">lockedInIndex</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line">        e.preventDefault();</div><div class="line">        alert(<span class="string">'I am link #'</span> + lockedInIndex);</div><div class="line">    &#125;;</div><div class="line">&#125;)(i), <span class="string">'false'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>自执行匿名函数和立即执行的函数表达式区别</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 这是一个自执行的函数，函数内部执行自身，递归</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; foo(); &#125;</div><div class="line"><span class="comment">// 这是一个自执行的匿名函数，因为没有标示名称</span></div><div class="line"><span class="comment">// 必须使用arguments.callee属性来执行自己</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">arguments</span>.callee(); &#125;;</div><div class="line"><span class="comment">// 这可能也是一个自执行的匿名函数，仅仅是foo标示名称引用它自身</span></div><div class="line"><span class="comment">// 如果你将foo改变成其它的，你将得到一个used-to-self-execute匿名函数</span></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; foo(); &#125;;</div><div class="line"><span class="comment">// 有些人叫这个是自执行的匿名函数（即便它不是），因为它没有调用自身，它只是立即执行而已。</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ());</div><div class="line"><span class="comment">// 为函数表达式添加一个标示名称，可以方便Debug</span></div><div class="line"><span class="comment">// 但一定命名了，这个函数就不再是匿名的了</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* code */</span> &#125; ());</div><div class="line"><span class="comment">// 立即调用的函数表达式（IIFE）也可以自执行，不过可能不常用罢了</span></div><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="built_in">arguments</span>.callee(); &#125; ());</div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; foo(); &#125; ());</div><div class="line"><span class="comment">// 另外，下面的代码在黑莓5里执行会出错，因为在一个命名的函数表达式里，他的名称是undefined</span></div><div class="line"><span class="comment">// 呵呵，奇怪</span></div><div class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123; foo(); &#125; ());</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="强大的原型和原型链"><a href="#强大的原型和原型链" class="headerlink" title="强大的原型和原型链"></a>强大的原型和原型链</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><hr>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> decimalDigits = <span class="number">2</span>,</div><div class="line">      tax =<span class="number">5</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> x + y;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">substract</span>(<span class="params">x,y</span>)</span>&#123;</div><div class="line">     <span class="keyword">return</span> x - y;</div><div class="line">&#125;</div><div class="line"><span class="comment">// alert(add(1,3));</span></div></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>原型使用方式1:</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Calculator = <span class="function"><span class="keyword">function</span> (<span class="params">decimalDigits, tax</span>) </span>&#123;</div><div class="line">        <span class="keyword">this</span>.decimalDigits = decimalDigits;</div><div class="line">        <span class="keyword">this</span>.tax = tax;</div><div class="line"> &#125;;</div><div class="line">Calculator.prototype = &#123;</div><div class="line">        <span class="attr">add</span>: <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> x + y;</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">subtract</span>: <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> x - y;</div><div class="line">        &#125;</div><div class="line"><span class="comment">//通过给Calculator对象的prototype属性赋值对象字面量来添加方法</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">//alert((new Calculator()).add(1, 3));</span></div></pre></td></tr></table></figure>
</li>
<li><p>原型使用方式2：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">    Calculator.prototype = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> x + y;</div><div class="line">            &#125;,</div><div class="line">            subtract = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">                <span class="keyword">return</span> x - y;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                <span class="attr">add</span>: add,</div><div class="line">                <span class="attr">subtract</span>: subtract</div><div class="line">            &#125;</div><div class="line">    &#125; ();</div><div class="line">    <span class="comment">//使用闭包，封装私有的function，通过return形式暴露出简单的使用名称</span></div><div class="line">    <span class="comment">//alert((new Calculator()).add(11, 3));</span></div><div class="line"></div><div class="line">- 分步声明</div><div class="line">    </div><div class="line">   上述使用原型的时候，有一个限制就是一次性设置了原型对象，我们再来说一下如何分来设置原型的每个属性吧</div><div class="line">    <span class="string">``</span><span class="string">`javascript</span></div><div class="line">    var BaseCalculator = function () &#123;</div><div class="line">    //为每个实例都声明一个小数位数</div><div class="line">    this.decimalDigits = 2;</div><div class="line">    &#125;;     </div><div class="line">    //使用原型给BaseCalculator扩展2个对象方法</div><div class="line">    BaseCalculator.prototype.add = function (x, y) &#123;</div><div class="line">    return x + y;</div><div class="line">    &#125;;</div><div class="line">    BaseCalculator.prototype.subtract = function (x, y) &#123;</div><div class="line">    return x - y;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p> 创建完BaseCalculator后：</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Calculator = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">//为每个实例都声明一个税收数字</span></div><div class="line"><span class="keyword">this</span>.tax = <span class="number">5</span>;</div><div class="line">&#125;;  </div><div class="line">Calculator.prototype = <span class="keyword">new</span> BaseCalculator();</div><div class="line"><span class="comment">//通过把BaseCalculator的实例赋给Calculator的原型来实现继承</span></div><div class="line"><span class="comment">//这样的一个缺点就是Calculator的实例将会可以访问BasCalculator中的decimalDigits</span></div><div class="line"><span class="comment">//Calculator.prototype = BaseCalculator.prototype  </span></div><div class="line"><span class="comment">//这样即可，此时Calculator的实例将无法访问decimalDigits</span></div></pre></td></tr></table></figure>
</li>
<li><p>重写原型</p>
<p> 第三方JS类库中定义的原型方法不能满足我们的需要，在依旧使用这个库的情况下，可以通过继续声明同样的代码来覆盖前面的功能（重写的代码必须放在后面）</p>
</li>
</ul>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><hr>
<ul>
<li>属性查找</li>
</ul>
<p>当查找一个对象的属性时，JavaScript 会首先查找这个对象，然后向上遍历原型链，直到找到给定名称的属性为止，到查找到达原型链的顶部 - 也就是 Object.prototype - 但是仍然没有找到指定的属性，就会返回 undefined</p>
<ul>
<li>hasOwnProperty函数</li>
</ul>
<p>hasOwnProperty是Object.prototype的一个方法，它可是个好东西，他能判断一个对象是否包含自定义属性而不是原型链上的属性，因为hasOwnProperty 是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。</p>
<p>但有个恶心的地方是：JavaScript 不会保护 hasOwnProperty 被非法占用，因此如果一个对象碰巧存在这个属性，就需要使用外部的 hasOwnProperty 函数来获取正确的结果（通过调用call或者apply方法）</p>
<blockquote>
<p>To be Continued…</p>
</blockquote>


                <hr>

                
                <!-- 多说 Share start -->
                </style>
                <div class="ds-share"
                    style="text-align: right"
                    data-thread-key="2016/04/10/2016-04-10-深入理解JavaScript系列读书笔记-一/"
                    data-title="深入理解JavaScript系列读书笔记"
                    data-url="http://rubicker.github.io/2016/04/10/2016-04-10-深入理解JavaScript系列读书笔记-一/"
                    data-images=""
                    data-content="
总结自汤姆大叔分享的文章——深入理解JavaScript系列


编写高质量JavaScri... | Rubicker的博客 | Rubicker&#39;s Blog " >
                    <div class="ds-share-inline">
                      <ul  class="ds-share-icons-16">
                        <li data-toggle="ds-share-icons-more"><a class="ds-more" href="#">分享到：</a></li>
                        <li><a class="ds-wechat flat" href="javascript:void(0);" data-service="wechat">微信</a></li>
                        <li><a class="ds-weibo flat" href="javascript:void(0);" data-service="weibo">微博</a></li>
                        <li><a class="ds-douban flat" href="javascript:void(0);" data-service="douban">豆瓣</a></li>
                      </ul>
                      <div class="ds-share-icons-more">
                      </div>
                    </div>
                <hr>
                </div>
                <!-- 多说 Share end-->
                

                <ul class="pager">
                    
                        <li class="previous">
                            <a href="/2016/04/11/2016-04-11-《深入理解Bootstrap》笔记/" data-toggle="tooltip" data-placement="top" title="《深入理解Bootstrap》笔记">&larr; Previous Post</a>
                        </li>
                    
                    
                        <li class="next">
                            <a href="/2016/04/09/2016-04-09-Emmet-强大的生产力工具/" data-toggle="tooltip" data-placement="top" title="Emmet-强悍的编辑器插件">Next Post &rarr;</a>
                        </li>
                    
                </ul>

                
                <!-- 多说评论框 start -->
                <div class="comment">
                    <div class="ds-thread"
                        data-thread-key="2016/04/10/2016-04-10-深入理解JavaScript系列读书笔记-一/"
                        data-title="深入理解JavaScript系列读书笔记"
                        data-url="http://rubicker.github.io/2016/04/10/2016-04-10-深入理解JavaScript系列读书笔记-一/" >
                    </div>
                </div>
                <!-- 多说评论框 end -->
                

                

            </div>
    <!-- Side Catalog Container -->
        

    <!-- Sidebar Container -->

            <div class="
                col-lg-8 col-lg-offset-2
                col-md-10 col-md-offset-1
                sidebar-container">

                <!-- Featured Tags -->
                
                <section>
                    <!-- no hr -->
                    <h5><a href="/tags/">FEATURED TAGS</a></h5>
                    <div class="tags">
                       
                          <a class="tag" href="/tags/#JavaScript" title="JavaScript">JavaScript</a>
                        
                    </div>
                </section>
                

                <!-- Friends Blog -->
                
            </div>

        </div>
    </div>
</article>


<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
    // dynamic User by Hux
    var _user = 'rubicker';

    // duoshuo comment query.
    var duoshuoQuery = {short_name: _user };
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>
<!-- 多说公共JS代码 end -->






<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script>
    async("http://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js",function(){
        anchors.options = {
          visible: 'always',
          placement: 'right',
          icon: '#'
        };
        anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
    })
</script>
<style>
    /* place left on bigger screen */
    @media all and (min-width: 800px) {
        .anchorjs-link{
            position: absolute;
            left: -0.75em;
            font-size: 1.1em;
            margin-top : -0.1em;
        }
    }
</style>



    <!-- Footer -->
    <!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                
                
                

                

                

                
                    <li>
                        <a target="_blank"  href="https://github.com/Rubicker">
                            <span class="fa-stack fa-lg">
                                <i class="fa fa-circle fa-stack-2x"></i>
                                <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                            </span>
                        </a>
                    </li>
                

                

                </ul>
                <p class="copyright text-muted">
                    Copyright &copy; Rubicker&#39;s Blog 2016 
                    <br>
                    Theme by <a href="http://huangxuan.me">Hux</a> 
                    <span style="display: inline-block; margin: 0 5px;">
                        <i class="fa fa-heart"></i>
                    </span> 
                    Ported by <a href="http://blog.kaijun.rocks">Kaijun</a> | 
                    <iframe
                        style="margin-left: 2px; margin-bottom:-5px;"
                        frameborder="0" scrolling="0" width="91px" height="20px"
                        src="https://ghbtns.com/github-btn.html?user=kaijun&repo=hexo-theme-huxblog&type=star&count=true" >
                    </iframe>
                </p>
            </div>
        </div>
    </div>
</footer>

<!-- jQuery -->
<script src="/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="/js/bootstrap.min.js"></script>

<!-- Custom Theme JavaScript -->
<script src="/js/hux-blog.min.js"></script>


<!-- async load function -->
<script>
    function async(u, c) {
      var d = document, t = 'script',
          o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function (e) { c(null, e); }, false); }
      s.parentNode.insertBefore(o, s);
    }
</script>

<!-- 
     Because of the native support for backtick-style fenced code blocks 
     right within the Markdown is landed in Github Pages, 
     From V1.6, There is no need for Highlight.js, 
     so Huxblog drops it officially.

     - https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0  
     - https://help.github.com/articles/creating-and-highlighting-code-blocks/    
-->
<!--
    <script>
        async("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function(){
            hljs.initHighlightingOnLoad();
        })
    </script>
    <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet">
-->


<!-- jquery.tagcloud.js -->
<script>
    // only load tagcloud.js in tag.html
    if($('#tag_cloud').length !== 0){
        async("http://rubicker.github.io/js/jquery.tagcloud.js",function(){
            $.fn.tagcloud.defaults = {
                //size: {start: 1, end: 1, unit: 'em'},
                color: {start: '#bbbbee', end: '#0085a1'},
            };
            $('#tag_cloud a').tagcloud();
        })
    }
</script>

<!--fastClick.js -->
<script>
    async("http://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function(){
        var $nav = document.querySelector("nav");
        if($nav) FastClick.attach($nav);
    })
</script>


<!-- Google Analytics -->




<!-- Baidu Tongji -->


<!-- Side Catalog -->





<!-- Image to hack wechat -->
<img src="http://rubicker.github.io/img/icon_wechat.png" width="0" height="0" />
<!-- Migrate from head to bottom, no longer block render and still work -->

</body>

</html>
